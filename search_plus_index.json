{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is whuwzp's golearning wiki! 主要是学习go语言和高star项目阅读改进. Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-07-12 21:41:38 "},"1.html":{"url":"1.html","title":"安装配置","keywords":"","body":" go的安装和环境配置 安装 下载（国内不行，需要镜像） 安装tar -C /usr/local -xzf go1.9.tar.gz //解压至/usr/local目录下 配置 go配置说明 总共涉及两个环境变量见附录1：GOROOT和GOPATH。其中，GOROOT为go的安装目录（即/usr/local/go），GOPATH为工作目录（开发源码，中间文件等，可以添加多个）。 sudo gedit /etc/profile //下面编辑该文件，在末尾添加如下代码（需要去掉注释部分） //配置GOROOT export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin //配置GOPATH export GOPATH=$HOME/mygo export PATH=$PATH:$GOPATH/bin //保存文件，并使其生效 source ~/.profile //此时，可查看版本等 go version //不行则重启 注释： 配置GOROOT后，即可在系统任何位置执行go相关的命令见附录1，如go build、go install等。 配置GOPATH是工作区间，我是在用户目录下建了mygo文件夹，其中包含了三个子目录： bin目录包含可执行命令，存放go install命令生成的可执行文件（由export PATH=$PATH:$GOPATH/bin导致） pkg目录包含包对象，编译相关，go build src目录包含go的源文件，它们被组织成包（每个目录都对应一个包），使用go install时，会自动在该目录下找。 GoLand配置 原谅我第一次配置这些，如图：（要设置为文件的完整路径） hello world 码代码 mkdir $GOPATH/src/test/ mkdir $GOPATH/src/test/hello gedit $GOPATH/src/test/hello/hello.go //编辑hello.go文件，如下： package main import \"fmt\" func main() { fmt.Printf(\"Hello, world.\\n\") } 编译 go install test/hello //go install 会去 $GOPATH/src中去找，test/hello中的，.go文件 这时，在$GOPATH/bin中生成可执行文件hello。 执行 hello //这时，输出：Hello, world. 因为export PATH=$PATH:$GOPATH/bin，所以在任何输入hello，即相当于在那个路径执行见附录1。 附录 环境变量 添加环境变量：添加系统环境变量是为了更方便的使用命令，这样的话，在系统任何路径下输入某个命令a，即相当于执行该路径下的该命令a,而不用每次都写绝对路径。 下面以配置GOROOT为例进行详解： export GOROOT=/usr/local/go GOROOT为go的安装目录，在系统中输入路径时可以简写/usr/local/go为$GOROOT。类似 的还有，如默认的$HOME指代的就是当前用户的工作目录。 export PATH=$PATH:$GOROOT/bin 这是添加系统环境变量，这样的话，在系统任何路径下输入命令go即相当于执行/$GOROOT/bin/.go(将$GOROOT替换为/usr/local/go)，因此完整执行为：/usr/local/go/bin/.go。 go路径 在读docker源码时，发现有些函数标红，无法使用goland跳转，估计就是路径不对，于是查看import如下： import ( \"fmt\" \"os\" \"path/filepath\" \"runtime\" \"github.com/docker/docker/cli\" \"github.com/docker/docker/daemon/config\" \"github.com/docker/docker/dockerversion\" \"github.com/docker/docker/pkg/reexec\" \"github.com/docker/docker/pkg/term\" \"github.com/sirupsen/logrus\" \"github.com/spf13/cobra\" ) 于是，将docker文件夹，放在了D:\\code\\go\\src\\github.com\\docker目录下，这样就可以了 sublime text3 go 配置 参考网址：https://studygolang.com/articles/4938 Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-07-12 21:43:07 "},"2.html":{"url":"2.html","title":"GO语言圣经学习","keywords":"","body":" 《GO语言圣经》（gitbook上的开源书籍）读书笔记以及练习题。 程序结构 声明和赋值 “:=”是一个变量声明语句，而“=‘是一个变量赋值操作 i, j = j, i // 交换 i 和 j 的值 i, j := 0, 1 //声明并赋值 简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过： f, err := os.Open(infile) f, err := os.Create(outfile) // compile error: no new variables _, err ：= io.Copy(os.Stdout, resp.Body) // 也错误，因为只有err一个变量，且前面已经声明过了 解决的方法是第二个简短变量声明语句改用普通的多重赋值语言。 命令行标志参数 使用示例如下： $ flag -s / a ba c //其中flag为运行程序（可执行文件） //s为标志参数（前面的\"-\"应该相当于标识?） //再后面的\"a ba c\"就是flag.Args中的参数了 其他系统或命令行中常见的如： -h或者-help,是一个道理。这里的-s /表示用\"/\"分隔各个参数，-n用于忽略行尾的换行符。 $ flag -h //命令行输入 Usage of D:\\code\\go\\bin\\flag.exe: -n using enter or not -s string septer (default \" \") 书中实现代码如下： package main import ( \"flag\" \"fmt\" \"strings\" ) var n = flag.Bool(\"n\", false, \"using enter or not\") // 第一个n是指向标志参数n（第二个）的指针，flag.xxx()返回的是指针 //\"n\"为参数的名字，false为该参数的默认值，\"using enter or not\"为说明介绍 var s = flag.String(\"s\", \" \", \"septer\") func main() { flag.Parse() //必须使用这个使其生效 fmt.Print(strings.Join(flag.Args(), *s)) // *s，取该地址上参数的值，默认为\" \"（空格） if !*n { //*n，同理，默认为false fmt.Println() } } 自定义数据类型 type Celsius float64 // 摄氏温度 type Fahrenheit float64 // 华氏温度 这样Celsius，Fahrenheit就和int、float等具有相同的地位（当然底层还有的自然会不一样）。 只有相同类型的才具有\"==\"比较等特性。这样可以避免出现某些单位不一致等错误。 包和文件 同一个包（如tempconv）的多个go文件（假设有tempconc.go，conv.go两个源文件），则两个源文件都为package tempconv ，文件夹名为tempconv； 在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的； 当包被导入的时候，包内的成员将通过类似tempconv.CToF的形式访问 ; 由于CTOF为大写，因此包外引用后也可以使用（所有大写的变量和函数都可以供外部使用）； 按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv 作用域 语法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧对应的语法块那样。语法块内部声明的名字是无法被外部语法块访问的 ； 任何在在函数外部（也就是包级语法域） 声明的名字可以在同一个包的任何源文件中访问的 ； 对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包 ; 基础数据类型 整数 无符号和无符号：其中有符号整数采用2的补码形式表示，也就是最高bit位用作表示符号位，一个n-bit的有符号数的值域是从-2 到2 - 1。无符号整数的所有bit位都用于表示非负数，值域是0到2 - 1。 int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255 . 通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的 [1] 副词告诉Printf函数再次使用第一个操作数。第二，%后的 # 副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀 o := 0666 fmt.Printf(\"%d %[1]o %#[1]o\\n\", o) // \"438 666 0666\" 早期计算机世界只有一个ASCII字符集，美国信息交换标准代码。ASCII，更准确地说是美国的ASCII，使用7bit来表示128个字符；但是其他语言字符无法被表示。Unicode则是包含了所有的世界字符120000种，需要32bit，但是占用资源较多；utf-8是Unicode的一个标准，使用的是变长编码，提高了利用率。 复合型 字符串 字符串是不可修改的 数组 一般形式： var q [3]int = [3]int{1, 2, 3} 但是也可以指定一个索引和对应值列表的方式初始化 ：（实际USD等就是int类型的具体值） type Currency int const ( USD Currency = iota // 美元 EUR // 欧元 GBP // 英镑 RMB // 人民币 ) symbol := [...]string{USD: \"$\", EUR: \"€\", GBP: \"￡\", RMB: \"￥\"} fmt.Println(RMB, symbol[RMB]) 不同于很多语言，go中数组是不会作为隐式的指针传递的，也就是传入的是数组的复制品，并不会改变数组本身，这种复制本身效率低，可以用指针传入； slice（动态数组） 一般形式： months := [...]string{1: \"January\", /* ... */, 12: \"December\"} 一个slice由三个部分构成：指针、长度和容量。 内置的len和cap函数分别返回slice的长度和容量； 指针指向第一个slice元素对应的底层数组元素的地址； 内置的append函数用于向slice追加元素； 和数组不同的是，slice之间不能比较 ,slice唯一合法的比较操作是和nil比较 map（词典） map中所有的key都有相同的类型，所有的value也有着相同的类型 如果map元素类型是一个数字，你可以需要区分一个已经存在的0，和不存在而返回零值的0，可以像下面这样测试：（一个不存在的key，如a[k]将会返回0，所以要检验） age, ok := ages[\"bob\"]if !ok { /* \"bob\" is not a key in this map; age == 0. */ } map的key一定是要可以比较的，但是如果是slice则无法比较，可以采用下面方法将slice转化为string进行比较： func k(list []string) string { return fmt.Sprintf(\"%q\", list) } map的key需要是可以比较的，map本身不可比较，因此直接不行；结构体可以比较，所以可以作为key； 结构体 结构体的指针和结构体相同“功用”，不知道怎么表述，详见下例： package main import ( \"fmt\" ) func main () { type student struct { name string } var a student a.name = \"wang\" var b *student = &a var c *student =&a (*b).name = \"luo\" fmt.Printf(\"%T\\t%T\\n\", a, b) fmt.Println(a.name,b.name); c.name = \"wen\" fmt.Printf(\"%T\\t%T\\n\", a, c) fmt.Println(a.name,c.name); } //output main.student *main.student luo luo main.student *main.student wen wen 如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回,返回值一般为*student这样的； 结构体中成员小写则不可导出： package p type T struct{ a, b int } // a and b are not exported package q import \"p\" var _ = p.T{a: 1, b: 2} // compile error: can't reference a, b var _ = p.T{1, 2} // compile error: can't reference a, b 嵌入结构体 一个结构体包含其他结构体，避免重复写相同的成员 type Point struct { X, Y int } type Circle struct { Center Point Radius int } type Wheel struct { Circle Circle Spokes int } //访问方式： var w Wheel w.Circle.Center.X = 8 w.Circle.Center.Y = 8 w.Circle.Radius = 5 w.Spokes = 20 赋值太繁琐，可以采用匿名成员的方法： type Circle struct { Point Radius int } type Wheel struct { Circle Spokes int } //访问方式： var w Wheel w.X = 8 // equivalent to w.Circle.Point.X = 8 w.Y = 8 // equivalent to w.Circle.Point.Y = 8 w.Radius = 5 // equivalent to w.Circle.Radius = 5 w.Spokes = 20 但是字面值却无法简洁： //以下是错误的： w = Wheel{8, 8, 5, 20} // compile error: unknown fields w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields //以下是正确的方式 w = Wheel{Circle{Point{8, 8}, 5}, 20} w = Wheel{ Circle: Circle{ Point: Point{X: 8, Y: 8}, Radius: 5, }, Spokes: 20, // NOTE: trailing comma necessary here (and at Radius) } 匿名成员的应用在cache2go项目可以看到。 函数 函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value） 的调用类似函数调用。例子如下： func square(n int) int { return n * n } func negative(n int) int { return -n } func product(m, n int) int { return m * n } f := square fmt.Println(f(3)) // \"9\" f = negative //用函数进行赋值 fmt.Println(f(3)) // \"-3\" fmt.Printf(\"%T\\n\", f) // \"func(int) int\" f = product // compile error: can't assign func(int, int) int to func(int) int defer 当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。 匿名函数 函数squares返回另一个类型为 func() int 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用时匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。 func squares() func() int { var x int return func() int { x++ return x * x } } func main() { f := squares() fmt.Println(f()) // \"1\" fmt.Println(f()) // \"4\" fmt.Println(f()) // \"9\" fmt.Println(f()) // \"16\" } 我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。 func (i int) int { fmt.print(i) }(2) //2是匿名函数的传入值，没有则空着 方法 方法和函数的对比 package geometry import \"math\" type Point struct{ X, Y float64 } // traditional function func Distance(p, q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } // same thing, but as a method of the Point type func (p Point) Distance(q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } 这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子： import \"gopl.io/ch6/geometry\" perim := geometry.Path{{1, 1}, {5, 1}, {5, 4}, {1, 1}} fmt.Println(geometry.Path.Distance(perim)) // \"12\", standalone function,采用函数，需要外加包名 fmt.Println(perim.Distance()) // \"12\", method of geometry.Path ，采用方法，则无需 基于指针对象的方法 一般声明方法 func (p *Point) ScaleBy(factor float64) { p.X *= factor p.Y *= factor } 这个方法的名字是 (*Point).ScaleBy 。 为什么要用指针？ 用途1：当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法 ； 用途2： 见下例： package main import ( \"fmt\" ) func main() { var jack student jack.name = \"zhang\" jack.changeName1(\"wang\") fmt.Printf(\"the name is %s\\n\", jack.name) jack.changeName2(\"wang\") fmt.Printf(\"the name is %s\\n\", jack.name) } type student struct { name string } func (li student) changeName1(s string) { li.name = s } func (li *student) changeName2(s string) { li.name = s } //output the name is zhang the name is wang 注： 一般来说，第二个方法的名字是：student.changeName2，因此需要用一个指针，但是我们并没有用(&jack).changeName2（就是先取下地址），这是因为编译器会隐式地为我们取变量的地址。另一方面，，也可以可以用一个 Point 这样的接收器来调用Point的方法，因为编译器在这里也会给我们隐式地插入 * 这个操作符 。 引用作者原文：不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型 进行调用的，编译器会帮你做类型转换 由此分析，我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal 接口 接口是约定 在微信项目源码分析和改进中可以熟悉接口的使用。 线程 goroutine 当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。 channel 无缓存（同步）channel 一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。 关闭channel： //使用下式关闭channel： close(naturals) //用这种方法验证close与否 x, ok := 带缓存channel 一般形式： ch = make(chan string, 3) 向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。 串联的Channels（Pipeline） Channels也可以用于将多个goroutine链接在一起，一个Channels的输出作为下一个Channels的输入。这种串联的Channels就是所谓的管道（pipeline） 。 书里的例子直接搬过来，比较好懂： func main() { naturals := make(chan int) squares := make(chan int) // Counter go func() { for x := 0; ; x++ { naturals 单方向channel 类型 chan 基于select的多路复用 select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的； 一个没有任何case的select语句写作select{}，会永远地等待下去； 如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会； 其他 标签break 这里的break语句用到了标签break，这样可以同时终结select和for两个循环；如果没有用标签就break的话只会退出内层的select循环，而外层的for循环会使之进入下一轮select循环。 loop: for { select { case size, ok := 练习题 练习题的代码见我的github账户，地址：github.com/whuwzp/goland-learning/gopl 第八章：Goroutines和Channels 练习8.1 我的方法如下： //server package main import ( \"io\" \"log\" \"net\" \"time\" \"flag\" ) func main() { var port = flag.String(\"port\", \"\", \"connect port\") //创建flag参数 flag.Parse() listener, err := net.Listen(\"tcp\", \"localhost:\" + *port) //根据flag参数确定端口 if err != nil { log.Fatal(err) } for { conn, err := listener.Accept() if err != nil { log.Print(err) continue } go handleConn(conn) } } func handleConn(c net.Conn) { defer c.Close() for { _, err := io.WriteString(c, time.Now().Format(\"15:04:05\\n\")) if err != nil { return // e.g., client disconnected } time.Sleep(1 * time.Second) } } //clockwall package main import ( \"io\" \"log\" \"net\" \"os\" ) func main() { var ch = make(chan bool) ports := [...]string{\"8010\", \"8020\", \"8030\"} //便于添加新的服务器端口 for _, port := range ports { go conn(port) //采用多线程的方式 } 更新：clockwall也可以使用匿名函数进行简化： func main() { var ch = make(chan bool) ports := [...]string{\"8010\", \"8020\", \"8030\"} //便于添加新的服务器端口 for _, port := range ports { go func(p string){ conn, err := net.Dial(\"tcp\", \"localhost:\"+ p) if err != nil { log.Fatal(err) } defer conn.Close() mustCopy(os.Stdout, conn) }(port) //传入值 } 练习8.3 试了一下，好像*net.TCPConn并没有CloseRead和CloseWrite 两个方法（也找源码中找了，确实没有） //非答案，但是可以满足要求，也就是关闭了stdin，仍然会将最后的信息传回打印 go func() { io.Copy(os.Stdout, conn) log.Println(\"done\") done 练习8.8 其他不变，只需改handleconn如下： func handleConn(c net.Conn) { input := bufio.NewScanner(c) timeout := time.After(10 *time.Second) //初始化一个超时时间 for { select { case 练习8.9 这里就是把原先的main函数改为了函数，由main中路径的子路径依次调用 package main import ( \"flag\" \"fmt\" \"io/ioutil\" \"os\" \"path/filepath\" \"sync\" ) func main() { var n_main sync.WaitGroup // Determine the initial directories. flag.Parse() roots := flag.Args() if len(roots) == 0 { roots = []string{\"D:/test/\"} } // Traverse the file tree. for _, entry := range dirents(roots[0]){ n_main.Add(1) go du([]string{filepath.Join(roots[0], entry.Name())}, &n_main) //因为之前没有加filepath.Join(roots[0], entry.Name())，而是直接用entry.name //出现 the system cannnot find the file specified的错误 //因为只是文件名，没有加进路径 } n_main.Wait() } func du(roots []string, n_m *sync.WaitGroup) { defer n_m.Done() fileSizes := make(chan int64) var n sync.WaitGroup n.Add(1) go walkDir(roots[0], &n, fileSizes) var nfiles, nbytes int64 go func() { n.Wait() close(fileSizes) }() for f := range fileSizes{ nfiles++ nbytes += f } printDiskUsage(nfiles, &roots, nbytes) // final totals } func printDiskUsage(nfiles int64, r *[]string, nbytes int64) { fmt.Printf(\"%s: %d files %.3f GB\\n\", (*r)[0], nfiles, float64(nbytes)/1e9) } func walkDir(dir string, n *sync.WaitGroup, fileSizes chan Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-07-12 21:27:33 "},"3.html":{"url":"3.html","title":"微信公众号","keywords":"","body":" 大神的项目源码地址：github.com\\leeeboo\\wechat，他的项目主要是微信公众号后端实现。主要学习了接口的使用、net/http的相关原理、调用关系。 [TOC] 微信公众号后台原理 关注用户微信平台公众号后台服务器 在微信注册时会让设置URL（服务器IP、域名等）和token（用于微信和后台间通信的验证）; 用户发消息，首先到达微信平台，由微信转发（加token等验证）给公众号拥有者自己的后台服务器（回复为逆过程）； 该项目就是在后台服务器部分。 源码分析 概要 由于go语言本身提供了良好的net.http接口，所以开发相对较为容易。大体上，http提供了ServeHTTP接口，我们只需要设置处理函数handler对接，并且实现该接口即可。因此重点有两个：对接和实现。 对接 go提供了接口，所以第一步我们需要找到对接方法，然后再去实现。 如图所示，是main对接http接口的实现概要。PDF文件清晰版 main 主要代码如下code1：（不重要略） //code1 server := http.Server{ Addr: fmt.Sprintf(\":%d\", port), Handler: &httpHandler{}, ... } log.Fatal(server.ListenAndServe()) 可以查看http.Server，实际对接已经完成了，也就是&httpHandler{}（如下code2可以看出结构体httpHandler的指针具有ServeHTTP方法，所以需要取地址符&）。因而*httpHandler实现了http.Handler的ServeHTTP接口。 //code2 type httpHandler struct {} func (*httpHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {...} 一般来说，我们只需要对接上，其余的只需要ListenAndServe监听，然后开发处理函数就好，没必要继续。但是这里我稍微看了一下http中的包。 ListenAndServe 简要代码如下code3。可以看出*(http.Server)具有ListenAndServe的方法（监听addr），最终调用(*(http.Server)).Serve方法。 //code3 func (srv *Server) ListenAndServe() error { addr := srv.Addr ... ln, err := net.Listen(\"tcp\", addr) ... return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)}) } Serve 这里Serve进入了大循环，接收新连接。新建了连接c，并调用了c.serve。http.conn的解释见下。 //code4 func (srv *Server) Serve(l net.Listener) error { ... for { ... rw, e := l.Accept() ... c := srv.newConn(rw) ... go c.serve(ctx) } }; coon //code5 type conn struct { server *Server } //(*conn)的方法serve func (c *conn) serve(ctx context.Context) { ... serverHandler{c.server}.ServeHTTP(w, w.req) //c结构体具有成员server，其类型为(*Server)，而code6可以看出，serverHandler结构体具有(*Server)类型成员。 //感觉有点绕，按理说如果conn实现了ServeHTTP接口，那就可以直接c.server.ServeHTTP(w, w.req)了。当然go自有它的道理吧，不深究。 ... } serverHandler //code6 type serverHandler struct { srv *Server } //serverHandler的方法ServeHTTP func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler //sh.srv即为Server类型，其具有Handler的成员，由main函数可知，我们已经预设了Handler成员为&httpHandler{}。所以最终到达了我们需要自己去实现的方法这里。 ... handler.ServeHTTP(rw, req)//调用实现了ServeHTTP接口的方法 } httpHandler //code7 type httpHandler struct { } //实现Handler的ServeHTTP接口 func (*httpHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { ...//自己开发部分 } 实现 上节找到了需要我们自己实现的部分（完成了对接）。 用户请求方法主要为GET和POST两种方法，因此大神写了两个方法，具体调用哪一个则交由(httpHandler).ServeHTTP进行判断选择。（所以文件名为route也是有原因的，负责将请求路由到具体处理函数上，本身不做具体处理）。而路由依据就是r http.Request，也就是输入。 处理函数组 首先说明POST和GET处理函数。利用init把这两种处理函数加入数组。 //code8 type WebController struct { Function func(http.ResponseWriter, *http.Request) Method string Pattern string } var mux []WebController func init() { mux = append(mux, WebController{post, \"POST\", \"^/\"}) mux = append(mux, WebController{get, \"GET\", \"^/\"}) } 路由函数ServeHTTP 其实就是看r.Method匹配是POST还是GET。然后调用。 //code9 func (*httpHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { t := time.Now() for _, webController := range mux { if m, _ := regexp.MatchString(webController.Pattern, r.URL.Path); m { if r.Method == webController.Method { webController.Function(w, r) go writeLog(r, t, \"match\", webController.Pattern) return } } } ... } 处理函数GET 一般先GET，后POST。GET就是请求，并且参数直接放在URL中，POST复杂些，相对来说参数安全些。 简要代码如下：主要是验证请求和返回结果。 //code10 func get(w http.ResponseWriter, r *http.Request) { client, err := wx.NewClient(r, w, token) ... w.Write([]byte(client.Query.Echostr))//输出部分 ... } NewClient 这里代码就不贴了，主要完成的是提取请求的相关信息并验证签名（也就是自己在微信公众平台上设置的），微信与后台服务器通信的验证token（当然还有其他信息合成的签名）。 处理函数POST 前面的处理同GET，多了一个client.run(). //code11 func (this *WeixinClient) Run() { err := this.initMessage() MsgType, ok := this.Message[\"MsgType\"].(string) switch MsgType { case \"text\": this.text() ... } return } //initMessage //在initMessage中读取了请求，并且赋值（因为了指针参数，可以直接修改）。并且还有之前的map中检查是否存在key的验证应用。 func (this *WeixinClient) initMessage() error { body, err := ioutil.ReadAll(this.Request.Body) m, err := mxj.NewMapXml(body) message, ok := m[\"xml\"].(map[string]interface{}) if !ok { return errors.New(\"Invalid Field `xml` Type.\") } } //text func (this *WeixinClient) text() { inMsg, ok := this.Message[\"Content\"].(string) var reply TextMessage reply.Content = value2CDATA(fmt.Sprintf(\"我收到的是：%s\", inMsg)) replyXml, err := xml.Marshal(reply)//常用语xml this.ResponseWriter.Header().Set(\"Content-Type\", \"text/xml\")//设置header参数 this.ResponseWriter.Write(replyXml)//最后写入reply } 关于文本、格式相关的没有深究。 测试调试 真正的调试方法将程序应该是部署在自己的服务器上，但这样调试成本太高（而且我只是代码分析，没必要专门部署）。因此有以下简洁的调试方法： ngrok 将外网地址映射到本机。申请一个账号，完成外网url到本机localhost端口的映射，然后在微信平台设置URL为该URL，即可。 模拟微信平台 在了解了通信原理之后，其实调试只需要伪装成微信平台即可，我之前想过，但是POST包构造不会，这里大神提供了测试代码。这个就不多讲了。 源码地址：github.com\\leeeboo\\wechat-mp-debugger 经验总结 熟悉了goland的单步调试，很好分析运行步骤和变量情况； 运用了很多指针方法、接口等概念，学习了相关知识； 自己绘制了流程图，这样确实很好看整个架构，尤其是http名称太多相似的时候，借助流程图很方便。 goland的使用： Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-04-25 23:09:53 "},"4.html":{"url":"4.html","title":"微信公众号2","keywords":"","body":" 大神的项目源码地址：github.com\\leeeboo\\wechat，他的项目主要是微信公众号后端实现。本文是试图进行改进。 [TOC] 改进思路 当时觉得用两个function不如试试用接口，但其实最后没觉得简单多少。（尴尬） 实现代码 方法1（可行） 因为go中的数组和c系列一样，必须是同类型的变量（Python无限制），所以我想让workers自动遍历的时候就会很麻烦，因此只能采用这种比较死的方法实现（具体见经验总结）： package main import ( \"io\" \"net/http\" \"time\" \"log\" \"github.com/leeeboo/wechat-new/wx\" \"regexp\" ) type Jobber interface { //jod的接口 job(w http.ResponseWriter, r *http.Request) } type Base struct { //这个基本成员一致 Method string Pattern string } type Get struct { Base } type Post struct { Base } type Workers struct {//两个实现接口 num int Get Post } var GET = Get{Base{\"GET\", \"^/\"}} var POST = Post{Base{\"POST\", \"^/\"}} var workers Workers func init() { workers = Workers{2,GET, POST}//加入两个实现 } type httpHandler struct { } func (*httpHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { t := time.Now() //复杂就在这里，尝试了很多方法，希望可以利用类似索引的东西去自动遍历、匹配，但是由于get、post分别为不同类型，无法使用数组、slice这样的（它们都是同类型集合），只能使用结构体，但是结构体没法遍历，只能使用`.`符号 if workers.Get.Method == r.Method{ if m, _ := regexp.MatchString(workers.Get.Pattern, r.URL.Path); m{ workers.Get.job(w, r) go writeLog(r, t, \"unmatch\", \"\") } } else { if workers.Post.Method == r.Method{ if m, _ := regexp.MatchString(workers.Post.Pattern, r.URL.Path); m{ workers.Post.job(w, r) go writeLog(r, t, \"unmatch\", \"\") } } } io.WriteString(w, \"\") return } //get实现接口，只是换成了接口，内部代码不变 func (g *Get) job(w http.ResponseWriter, r *http.Request) { client, err := wx.NewClient(r, w, token) if err != nil { log.Println(err) w.WriteHeader(403) return } if len(client.Query.Echostr) > 0 { w.Write([]byte(client.Query.Echostr)) return } w.WriteHeader(403) return } //POST func (p *Post) job(w http.ResponseWriter, r *http.Request) { client, err := wx.NewClient(r, w, token) if err != nil { log.Println(err) w.WriteHeader(403) return } client.Run() return } 另外关于定义类型系列可以按照如下简化：（这个原本是方法2想尝试的思路，不过也好用于简化） type Base struct { Method string Pattern string } type Get Base type Post Base type Workers struct { num int Get Post } 方法2（不可行） 就是之前的数组的问题，因为数组是要求同类型的，因此想到将Get和Post结构体设为相同类型结构体的子类型，如下： type Base struct { Method string Pattern string } type Get Base type Post Base var get = Get{\"GET\", \"^/\"} var post = Post{\"POST\", \"^/\"} func init() { fmt.Print(GET, POST,\"\\n\") var m = [...]Base{get, post} //error:cannot use get (type Get) as type Base in array or slice literal 还是出现了错误，显示Get仍然还是Get，而不是Base，因此不能算了同类。 方法3（应该可行，但是还不成功） 想利用map，m := map[string]struct{}的形式将两个method放在一起，这样就可以利用如下方法访问了。然而，遇到了问题，待解决，还不太熟悉结构体的原理。 for a, b := range m {} //形式遍历访问了 经验总结 相同底层类型但是不同类型间不可直接比较； type Get string var GET Get = \"GET\" if r.Method == GET {}//报错，不同类型 结构体的声明，要么字面值声明如下： type Base struct { Method string Pattern string } type Get struct { Base } var GET = Get{Base{\"GET\", \"^/\"}} 在函数外，只可以定义声明放在一起，不可以单独赋值（也就是声明变量时即赋值，不可以声明之后再赋值）； 还有一个和Python不太一样的地方，go中的数组和c系列一样，必须是同类型的变量（Python无限制），所以我想让workers自动遍历的时候就会很麻烦： 必须新建type，因为string等不能用来实现接口； 如果采用type Get string和type POST string这样的话，数组就不能包含这两个，因为不同类型，当然可以用string(GET)、string(POST)来转化，但是这样一来也会无法使用我们为这两个类型添加的方法了（job），那样数组中的仅仅就是字符串了，丢失了原有的特性方法； 代码如下： type Get struct { } type Post struct { Pattern string //把这行注释掉就ok } var m = map[string]struct{}{ \"GET\": Get{}, //ok \"POST\": Post{}, //error：cannot use a literal (type a) as type struct {} in assignment } ​ Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-03-19 21:57:41 "},"5.html":{"url":"5.html","title":"kaca项目1","keywords":"","body":" kaca的项目源码地址：github.com/scottkiss/kaca，他的项目主要是基于websokcet实现消息订阅与发布系统。本节主要分析server端工作原理。主要学习了goroutine（多线程）、channel、基于select的多路复用、defer函数的使用等 。 [TOC] 消息订阅发布原理 sub——>系统（订阅主题） pub——>系统（发布消息） 系统——>sub（推送消息） suber向系统订阅自己感兴趣的内容（topic），puber向系统发布消息，系统将消息发给订阅了相应主题的suber。可以类比之前的Ryu控制器的工作原理：应用层APP向opf.handler（Ryu控制器内核，会将openflow消息转化为相应事件）订阅各自需要接收的事件（事件类型），ofp.handler就会将底层发来的事件（原始为消息）发给订阅者。 源码分析 概要 kaca项目就是利用web的C/S模型来实现的消息订阅发布，其中suber和puber为client，系统为server。本节主要分析server端。由上原理可知，server端主要有以下任务： 与net.http的接口对接，即利用websocket模型监听消息、处理消息； 具体的处理函数，包含多client下的高效服务（多线程）、sub/pub模型实现（中心调度模块）。 server端源码： //code1 go disp.run() //负责调度 if checkOrigin { http.HandleFunc(\"/ws\", serveWsCheckOrigin) //注册serveWsCheckOrigin为pattern的处理函数（实现对接） } else { http.HandleFunc(\"/ws\", serveWs) } err := http.ListenAndServe(addr, nil) //开始监听 对接 net.http的注册和监听处理整体如下图所示：PDF清晰版 其实整体步骤和微信项目差不太多，只是在ListenAndServe阶段的处理函数不一样，如下： //code2 func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux //和之前不同，这里采用的是默认处理函数 } handler.ServeHTTP(rw, req) } 采用的是默认的处理函数，当然这个处理函数就是在code1中注册的serveWsCheckOrigin，具体注册方法类似，也是实现了接口ServeHTTP的方式完成的。这里稍稍提一下以下代码： //code3 func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { mux.Handle(pattern, HandlerFunc(handler)) //handler即为serveWsCheckOrigin，HandlerFunc()是类型转换操作 //即将一个函数转化另一个函数类型 //因此具备了该函数类型的方法，从而实现接口 } type HandlerFunc func(ResponseWriter, *Request) //转换为此类型，因此转换后具有ServeHTTP的方法 // ServeHTTP calls f(w, r). func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) //实际就是执行函数serveWsCheckOrigin //ServeHTTP中的handler.ServeHTTP(rw, req) //handler即为HandlerFunc(handler) } 函数类型的也可以具有方法，从而实现某接口； 虽然最后调用f(w, r)和调用函数本身没差别，但是实现了统一的接口，便与开发； 可以用类似HandlerFunc(handler)将函数转化为其他类型函数。 处理函数 概要 首先为了实现sub/pub模型： 肯定需要建立一个map，也就是每个client感兴趣的topic表，利用sub消息建立； 依据这个map，将client发布的pub消息发送给特定topic的client。 多线程服务：利用goroutine实现多个连接的同时服务。 多线程 dispatch->run //每个连接的dispatch线程处理后交由run（中心调度模块）处理； . run->deliver //run处理后（涉及map、topic等，以确定发给谁、添加至map等操作），如有需要发送处理的则由deliver发送。 //code4 func serveWsCheckOrigin(w http.ResponseWriter, r *http.Request) { disp.register 主要由三个函数实现： run 为了实现多线程的高效服务，大神首先启用了调度器的线程，该线程无限循环，负责中心调度； //code5 go disp.run() func (d *dispatcher) run() { for { select { //新连接的注册，添加至connections map[*connection]bool表 case c := dispatch：每个连接（也就是client）都会启用一个线程，一个大循环处理pub/sub等消息，经过； //code6 func (c *connection) dispatch() { defer func() { disp.unregister deliver：run处理完后由deliver负责发送信息： //code7 func (c *connection) deliver() { ticker := time.NewTicker(pingPeriod) defer func() { ticker.Stop() c.ws.Close() }() for { select { case message, ok := pub/sub实现 其实pub/sub模型主要就是client和topic的映射，也就是订阅表，之后依据特定topic消息发送给特定订阅者。 订阅实现：约定消息中携带前缀的形式来标记和辨识sub或者pub。 //code8 //dispatch() msg := string(message) if strings.Contains(msg, SUB_PREFIX) { topic := strings.Split(msg, SUB_PREFIX)[1] //分离出topic disp.sub \" + m, msp) for c := range d.connections { if msp[0] == strconv.Itoa(int(c.cid)) { //为c的topic订阅表中增加topic c.topics = append(c.topics, msp[1]) } } 发布实现： //code9 //disptch() if strings.Contains(msg, PUB_PREFIX) { topic_msg := strings.Split(msg, PUB_PREFIX)[1] disp.pub \" + m) for c := range d.connections { //遍历所有连接 for _, t := range c.topics { if t == msp[0] { //如果连接（client）订阅了该topic select { case c.send Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-04-25 22:24:00 "},"6.html":{"url":"6.html","title":"kaca项目2","keywords":"","body":" kaca的项目源码地址：github.com/scottkiss/kaca，他的项目主要是基于websokcet实现消息订阅与发布系统。本节主要分析client端工作原理。主要学习了匿名函数的使用等 。 [TOC] 上节分析了server端，client端相对容易些（kaca本身就是实现服务架构）。 源码分析 概要 client端的工作比较简单，分为以下： 创建连接，同server端进行连接，类似server端tcp绑定，client端连接； 订阅感兴趣的topic（上节分析可以看出订阅原理）、发布消息等。 连接 NewClient->websocket.DefaultDialer.Dial函数建立连接（具体还待进一步分析）。返回&client。 订阅发布 //code1 func (c *client) Sub(topic string) { sendMsg := SUB_PREFIX + topic //上节说的标记方法，便于server端识别 err := c.conn.WriteMessage(websocket.TextMessage, []byte(sendMsg)) //相当于发送了 } //发布同理 经验总结 client相对简单，唯一注意到以下代码，即匿名函数的使用： //code2 consumer.ConsumeMessage(func(message string) { //将匿名函数作为传入值 fmt.Println(\"consume =>\" + message) }) 可以看出，将匿名函数作为传入值： //code3 func (c *client) ConsumeMessage(f func(m string)) { //定义了一个匿名函数，作为传入值 go func() { //启用一个线程，大循环接收消息 for { _, message, err := c.conn.ReadMessage() if err != nil { log.Println(\"read:\", err) break } log.Printf(\"recv: %s\", message) f(string(message)) //调用f打印消息 } }() //使用了匿名函数，最后的括号内为匿名函数的传入值 } 可以看到使用了两个匿名函数：一个是传入值，一个是函数内的匿名函数。 好像显得很麻烦，因为完全可以不要那个传入值，直接import \"fmt\"，进行打印。可能是为了避免多import，或者就是为了炫技呢，哈哈，厉害了大神！ Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-03-19 21:57:56 "},"7.html":{"url":"7.html","title":"grpool项目1","keywords":"","body":" 大神源码：github.com/ivpusic/grpool。他的代码实现的是任务多线程化。主要学习了goroutine和channel的使用。 [TOC] 概要 总的来说，整体系统由dispatch和worker（开始大循环工作）组成。比较简单，不一一分析了。 dispatch：相当于路由，接收JobQ中的新任务，然后找到一个worker，扔进他的channel中，循环； worker：从各自channel中接收分配的任务，完成，又重新加入到workerpool中，循环。 源码分析 channel的使用 type worker struct { workerPool chan *worker //可以看出使用指针作为channel的传输类型 jobChannel chan Job //可以看出使用函数作为channel的传输类型 stop chan struct{} } type Job func() 任务完成后将worker又加入到原pool中，这点很重要 func (w *worker) start() { go func() { var job Job for { // worker free, add it to pool w.workerPool Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-03-19 15:03:23 "},"8.html":{"url":"8.html","title":"grpool项目2","keywords":"","body":" 大神源码：github.com/ivpusic/grpool。他的代码实现的是任务多线程化。主要学习了goroutine和channel的使用。上节源码进行了分析，本节想试着改进一下。改进代码地址：github.com/whuwzp/goland-learning/grpool-test/grpool.go。 [TOC] 改进目标 就是觉得workpool，jobqueue，dispatcher等太繁杂了，希望能简化这些。 改进方法 改机思路1 将pool改为全局变量，这样就无需每次都传递这个变量或者是地址。 代码如下： package grpool import ( ) var pool Pool //变为全局变量 type Job func() //无需加入workerpool的成员变量 //不需要NewWorker中传入pool //每个worker也不用都携带pool的地址 type Worker struct { JobChannel chan Job Stop chan struct{} } type Pool struct { Workers chan *Worker JobQueue chan Job } func NewPool (NumWorkers int, JobQueueLen int) *Pool { workers := make(chan *Worker, NumWorkers) jobqueue := make(chan Job, JobQueueLen) for i := 0; i 改进思路2 上面的方法中pool是全局变量，作用域太大，做了如下改动。在函数中加入&pool的传入值或者变为pool的方法。 代码如下： package grpool import ( ) type Job func() type Worker struct { JobChannel chan Job Stop chan struct{} } type Pool struct { Workers chan *Worker JobQueue chan Job } func NewPool (NumWorkers int, JobQueueLen int) *Pool { workers := make(chan *Worker, NumWorkers) jobqueue := make(chan Job, JobQueueLen) pool := &Pool{ Workers: workers, JobQueue: jobqueue, } for i := 0; i Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-03-19 15:03:23 "},"9.html":{"url":"9.html","title":"cache2go项目2","keywords":"","body":" 大神源码：github.com/muesli/cache2go。他的代码实现的是实现内存管理。主要学习了time、空接口等的使用。 [TOC] 源码分析 概要 缓存管理cache主要就是时间的问题，即到期删除，因此我主要是去搞清楚其监测原理，其核心方法expirationCheck 。 另外，由于涉及访问问题，因此访问锁Lock也需要注意需要使用。 清晰版PDF 核心 核心就是cache的到期管理问题，该项目在为cachetable增加新的item条目时会进行监测。 func (table *CacheTable) addInternal(item *CacheItem) { ... if item.lifeSpan > 0 && (expDur == 0 || item.lifeSpan func (table *CacheTable) expirationCheck() { table.Lock() if table.cleanupTimer != nil { table.cleanupTimer.Stop() } if table.cleanupInterval > 0 { table.log(\"Expiration check triggered after\", table.cleanupInterval, \"for table\", table.name) } else { table.log(\"Expiration check installed for table\", table.name) } now := time.Now() smallestDuration := 0 * time.Second for key, item := range table.items { item.RLock() lifeSpan := item.lifeSpan accessedOn := item.accessedOn item.RUnlock() if lifeSpan == 0 { continue } //距离上一次访问空闲的时间是否超过失效时间，如果是删除该项条目 if now.Sub(accessedOn) >= lifeSpan { // Item has excessed its lifespan. table.deleteInternal(key) } else { //这里类似冒泡算法，找出最近就要到期的item的剩余时间 if smallestDuration == 0 || lifeSpan-now.Sub(accessedOn) 0 { table.cleanupTimer = time.AfterFunc(smallestDuration, func() { go table.expirationCheck() //afterfunc配合goroutine用得很妙 }) } table.Unlock() } 复写 为了加强记忆，自己把代码的核心功能写了一下： 简易cache2go 只含有核心功能，代码如下： package my_cache2go import ( \"time\" \"sync\" \"fmt\" ) type item struct { sync.RWMutex key interface{} data interface{} lifespan time.Duration accesson time.Time } type cachetable struct { sync.RWMutex name string items map[interface{}]*item } var ( cache = make(map[string]*cachetable) mutex sync.RWMutex ) func Cache(name string) *cachetable { mutex.Lock() defer mutex.Unlock() t, ok := cache[name] if !ok{ t = &cachetable{ name: name, items: make(map[interface{}]*item), } cache[name] = t } return t } func (t *cachetable) Add(key interface{}, lifespan time.Duration, data interface{}) { item := &item{ key: key, data: data, accesson: time.Now(), lifespan: lifespan, } t.Lock() t.Addinternal(item) } func (t *cachetable) Addinternal(item *item) { _, ok := t.items[item.key] if !ok{ t.items[item.key] = item t.Unlock() t.expireCheck() } } func (t *cachetable) expireCheck() { smallest := 0 * time.Second for k, i := range t.items{ Now := time.Now() if Now.Sub(i.accesson) >= i.lifespan{ fmt.Println(\"over time, stating to delete\") t.delete(k) } if smallest == 0 || i.lifespan - Now.Sub(i.accesson) 0{ time.AfterFunc(smallest, func() { go t.expireCheck() }) } } func (t *cachetable) delete(key interface{}) { t.Lock() defer t.Unlock() delete(t.items, key) fmt.Println(\"deleting...\") } func (t *cachetable) Value(key interface{}) interface{} { t.Lock() defer t.Unlock() r, ok := t.items[key] if !ok { fmt.Println(\"not in cache!\") return nil } return r.data } main函数 package main import ( \"github.com/whuwzp/my_cache2go\" \"time\" \"fmt\" ) func main() { table := my_cache2go.Cache(\"test_table\") table.Add(\"test_item\", 5 * time.Second, \"just for test\") v1 := table.Value(\"test_item\") fmt.Println(\"the value is \", v1) time.Sleep(5500 * time.Millisecond) v2 := table.Value(\"test_item\") fmt.Println(\"the value is \", v2) } 经验总结 time函数使用 time.sleep 等待并阻塞一定时间 time.after 将返回一个channel，channel类型为time； 执行后，将在一定时间后向channel发送当前发送的时间； func main() { t1 := time.Now() tc1 := time.After(1 * time.Second) fmt.Println(\"wait1...\") time.Sleep(2 * time.Second) t2 := time.tick 和time.after差不多，只是这个是周期性的向channel发送时间，after是一次性的。 time.afterfunc 如下例：函数返回的t是*time.Timer类型，在t1时间后，执行传入的函数func()。 t := time.AfterFunc(t1, func() { go table.expirationCheck() }) 如果后悔，可以在执行函数func()前，使用stop结束而不执行。 time.after/before 判断时间点前后，返回true/false func main() { t1 := time.Now() time.Sleep(1 * time.Second) t2 := time.Now() a := t1.Before(t2) b := t1.After(t2) fmt.Println(a, b) } //执行结束 true false time.sub 计算时间差 func main() { t1 := time.Now() time.Sleep(1 * time.Second) t2 := time.Now() fmt.Println(t2.Sub(t1)) } //执行结果 1.0000572s 结构体匿名函数使用 结构体嵌套：一个结构体包含其他结构体，避免重复写相同的成员 type Point struct { X, Y int } type Circle struct { Center Point Radius int } //访问方式： var c Circle c.Center.X = 8 c.Center.Y = 8 c.Radius = 5 访问太繁琐，可以采用匿名成员的方法： type Circle struct { Point Radius int } //访问方式： var w Wheel c.X = 8 // equivalent to c.Center.X = 8 c.Y = 8 // equivalent to c.Center.Y = 8 c.Radius = 5 // equivalent to c.Radius = 5 在cache2go的项目中，很多结构体都嵌入了匿名成员RWMutex结构体，因此可以直接访问： type CacheTable struct { sync.RWMutex } type CacheItem struct { sync.RWMutex } 空接口 空接口的使用也是亮点，如下，可以使用任何类型的变量作为key，从而算了间接地实现类似Python字典不同类型搁一起的感觉。（之前的WeChat改进可以尝试） items map[interface{}]*CacheItem Lock 一个函数a获取了然后调用了其他的函数b，a中使用了Lock，则b中不需要再Lock了，否则阻塞。 t.Lock() Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-04-25 22:25:24 "}}